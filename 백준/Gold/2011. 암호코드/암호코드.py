
# 재귀로 풀면 시간복잡도가 O(2^N)따구로 나오기 때문에... DP로 풀어야 됨
# 앞의 글자를 기반으로 N 길이의 배열을 선언한 뒤에 한 칸씩 검사하면서 이전 검사값을 기준으로 계산

# 입력받기
ls = input().strip()

# 첫 숫자가 0이면 아예 해석할 수 없음
if (ls[0] == "0"):
    print(0)
    exit()

# 배열 길이
N = len(ls)

# dp 배열 선언, 초기화, 첫 부분들 작업(첫 숫자가 0이 아닌 걸 확인했으므로 1 넣고 시작)
# 뒤에 2개를 계산해서 그 앞에 넣어야 되니깐 N+1로 선언
dp = [0]*(N+1)
dp[0] = 1
dp[1] = 1

# 앞에 2개 작업했으니깐 3번째 인덱스부터 시작
for i in range(2, N + 1):
    one = int(ls[i-1])
    two = int(ls[i-2:i])
    
    # 1개 잘라서 1~9인지 먼저 확인
    if (one != 0):
        temp = dp[i] + dp[i-1]
        dp[i] = temp % 1000000
    # 이후 2개 잘라서 10~26인지 확인
    if (two >= 10 and two <= 26):
        temp = dp[i] + dp[i-2]
        dp[i] = temp % 1000000
# 최종 결과 출력
print(dp[-1])